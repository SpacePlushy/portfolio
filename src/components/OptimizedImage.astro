---
/**
 * OptimizedImage - Type-safe Astro component for optimized images
 * 
 * Features:
 * - Automatic format selection (AVIF, WebP, JPEG)
 * - Responsive image generation
 * - Blur placeholder support
 * - SEO-friendly attributes
 * - Error handling with fallbacks
 * - Performance optimizations
 */

import type { OptimizedImageProps } from '../types/image';
import { 
  generateResponsiveSources, 
  generateSizesAttribute, 
  buildOptimizedImageUrl,
  generateBlurPlaceholder,
  getOptimalFormat,
  detectBrowserCapabilities
} from '../utils/image';

export interface Props extends OptimizedImageProps {}

const {
  src,
  alt,
  width,
  height,
  className = '',
  style = {},
  quality = 80,
  format,
  formats = ['avif', 'webp', 'jpeg'],
  fit = 'cover',
  responsive = [],
  sizes,
  loading = 'lazy',
  priority = 'medium',
  placeholder = true,
  blurDataURL,
  fallbackSrc,
  role,
  'aria-label': ariaLabel,
  'aria-describedby': ariaDescribedBy,
  'data-testid': testId,
  ...restProps
} = Astro.props;

// Validate required props
if (!src) {
  throw new Error('OptimizedImage: src prop is required');
}
if (!alt) {
  console.warn('OptimizedImage: alt prop is required for accessibility');
}

// Generate optimized sources for responsive images
const responsiveSources = responsive.length > 0 
  ? generateResponsiveSources(src, responsive, { quality, format, fit })
  : [];

// Generate main image URL with optimizations
const mainOptimizationParams = {
  width: width || (responsive.length > 0 ? responsive[0].width : undefined),
  height: height || (responsive.length > 0 ? responsive[0].height : undefined),
  quality,
  format: format || getOptimalFormat(formats),
  fit,
};

const optimizedSrc = buildOptimizedImageUrl(src, mainOptimizationParams);

// Generate blur placeholder if enabled
let placeholderSrc = '';
if (placeholder === true && !blurDataURL) {
  placeholderSrc = generateBlurPlaceholder(
    width || 20,
    height || 15,
    '#f3f4f6'
  );
} else if (typeof placeholder === 'string') {
  placeholderSrc = placeholder;
} else if (blurDataURL) {
  placeholderSrc = blurDataURL;
}

// Generate sizes attribute for responsive images
const sizesAttr = sizes || (responsive.length > 0 ? generateSizesAttribute(responsive) : '100vw');

// Determine loading strategy
const shouldLazyLoad = loading === 'lazy' && priority !== 'high';
const fetchPriority = priority === 'high' ? 'high' : 'auto';

// Build style object
const imageStyle = {
  ...style,
  // Ensure proper aspect ratio if dimensions provided
  ...(width && height && {
    aspectRatio: `${width} / ${height}`,
  }),
};

// Error handling - fallback image
const fallbackImage = fallbackSrc || src;
---

<!-- Picture element for modern format support -->
{responsiveSources.length > 0 ? (
  <picture class={`optimized-image-picture ${className}`} data-testid={testId}>
    <!-- Generate source elements for each format -->
    {responsiveSources.map((source) => (
      <source
        srcset={source.srcSet}
        sizes={sizesAttr}
        type={`image/${source.format}`}
        media={source.format === 'avif' ? '(min-width: 0px)' : undefined}
      />
    ))}
    
    <!-- Main img element with fallback -->
    <img
      src={optimizedSrc}
      alt={alt}
      width={width}
      height={height}
      loading={shouldLazyLoad ? 'lazy' : 'eager'}
      fetchpriority={fetchPriority}
      style={imageStyle}
      class={`optimized-image ${className}`}
      role={role as any}
      aria-label={ariaLabel}
      aria-describedby={ariaDescribedBy}
      data-testid={testId}
      {...restProps}
    />
  </picture>
) : (
  <!-- Single img element for simple usage -->
  <img
    src={optimizedSrc}
    alt={alt}
    width={width}
    height={height}
    loading={shouldLazyLoad ? 'lazy' : 'eager'}
    fetchpriority={fetchPriority}
    style={imageStyle}
    class={`optimized-image ${className}`}
    role={role as any}
    aria-label={ariaLabel}
    aria-describedby={ariaDescribedBy}
    data-testid={testId}
    {...restProps}
  />
)}

<!-- Blur placeholder overlay (shown while loading) -->
{placeholderSrc && (
  <div
    class="optimized-image-placeholder"
    style={{
      backgroundImage: `url(${placeholderSrc})`,
      backgroundSize: 'cover',
      backgroundPosition: 'center',
      position: 'absolute',
      top: 0,
      left: 0,
      width: '100%',
      height: '100%',
      filter: 'blur(10px)',
      transform: 'scale(1.1)', // Prevent blur edge artifacts
      transition: 'opacity 0.3s ease-in-out',
      pointerEvents: 'none',
      zIndex: -1,
    }}
    aria-hidden="true"
  />
)}

<style>
  .optimized-image-picture {
    position: relative;
    display: inline-block;
    overflow: hidden;
  }
  
  .optimized-image {
    display: block;
    max-width: 100%;
    height: auto;
    transition: opacity 0.3s ease-in-out;
  }
  
  /* Loading state */
  .optimized-image[loading="lazy"] {
    opacity: 0;
  }
  
  .optimized-image.loaded {
    opacity: 1;
  }
  
  /* Hide placeholder when image is loaded */
  .optimized-image.loaded + .optimized-image-placeholder {
    opacity: 0;
  }
  
  /* Error state fallback */
  .optimized-image-error {
    background-color: #f3f4f6;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%236b7280' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Crect x='3' y='3' width='18' height='18' rx='2' ry='2'/%3E%3Ccircle cx='8.5' cy='8.5' r='1.5'/%3E%3Cpolyline points='21,15 16,10 5,21'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: center;
    background-size: 48px 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #6b7280;
    font-size: 0.875rem;
    min-height: 200px;
  }
  
  /* Aspect ratio containers */
  .optimized-image-aspect-16-9 {
    aspect-ratio: 16 / 9;
  }
  
  .optimized-image-aspect-4-3 {
    aspect-ratio: 4 / 3;
  }
  
  .optimized-image-aspect-1-1 {
    aspect-ratio: 1 / 1;
  }
  
  /* Performance optimizations */
  .optimized-image {
    content-visibility: auto;
    contain-intrinsic-size: 200px;
  }
  
  /* Reduce motion for accessibility */
  @media (prefers-reduced-motion: reduce) {
    .optimized-image,
    .optimized-image-placeholder {
      transition: none;
    }
  }
  
  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .optimized-image-placeholder {
      filter: contrast(1.2);
    }
  }
  
  /* Dark mode adjustments */
  @media (prefers-color-scheme: dark) {
    .optimized-image-error {
      background-color: #374151;
      color: #9ca3af;
    }
  }
</style>

<script>
  // Client-side enhancement for image loading states
  document.addEventListener('DOMContentLoaded', () => {
    const images = document.querySelectorAll('.optimized-image[loading="lazy"]');
    
    images.forEach((img) => {
      if (!(img instanceof HTMLImageElement)) return;
      
      // Handle successful load
      img.addEventListener('load', () => {
        img.classList.add('loaded');
        
        // Dispatch custom event for tracking
        img.dispatchEvent(new CustomEvent('optimized-image-loaded', {
          bubbles: true,
          detail: { src: img.src, loadTime: performance.now() }
        }));
      });
      
      // Handle load errors
      img.addEventListener('error', () => {
        img.classList.add('optimized-image-error');
        
        // Try fallback if available
        const fallback = img.dataset.fallback;
        if (fallback && img.src !== fallback) {
          img.src = fallback;
          return;
        }
        
        // Show error state
        console.warn(`Failed to load optimized image: ${img.src}`);
        
        // Dispatch error event
        img.dispatchEvent(new CustomEvent('optimized-image-error', {
          bubbles: true,
          detail: { src: img.src, error: 'Load failed' }
        }));
      });
    });
  });
</script>